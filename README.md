# fe-technology


1. Global Variable
2. Detatched DOM/DOM Ref - Discover detached DOM using Heap Snapshots
3. Timer
4. Closuer


Tool - Performance/Memory/Profiler

# JS

	#1
	var x = 10;
	function display() {
		console.log(x); //undefined
		var x = 20;
	}
	display();
	console.log(x); //10
	
	#2
	var obj = {
	x: 10,
		y: function() {
			console.log(this.x);//10
			setTimeout(function() {
				console.log(this.x);//undefined
			}, 500);
			setTimeout(() => {
				console.log(this.x);//10
			}, 500);
		}
	}
	obj.y();
	#3
	for(var i=0; i<5; i++) {
		setTimeout(() => {
			console.log(i);//5,5,5,5,5
		}, 500);
	}

	for(let i=0; i<5; i++) {
		setTimeout(() => {
			console.log(i);//0,1,2,3,4
		}, 500);
	}
	
	#4
	for(var i=0; i<5; i++) {
		var output = "";
		for(var j=0; j<(5-i); j++) {
			output += " ";
		}
		for(var k=0; k<=i; k++) {
			output += i + " ";
		}
		console.log(output);
	}
	#5 Prototype
	Objects in JavaScript have an internal property known as prototype. It is simply a reference to another object and
	contains common attributes/properties across all instances of the object. An objectâ€™s prototype attribute specifies
	the object from which it inherits properties.
	
	Function.prototype (spl property which refers to another object)
	
	Object.__proto__
	
	# Prob
	var arr = [2, 4, 4, 2, 2, 8, 5, 8, 8, 8, 8];
	var res = []; //[[2, 2, 2], [4, 4], [5], [8, 8, 8, 8, 8]]
	arr.filter((ele, i, a) => a.indexOf(ele) === i)
	    .sort((a, b) => a - b)
	  .forEach((ele) => {
	  res.push(arr.filter((e) => e === ele))
	});
	console.log(res);
	
# Promise vs Observable
	a Promise is eager, whereas an Observable is lazy,
	a Promise is always asynchronous, while an Observable can be either synchronous or asynchronous,
	a Promise can provide a single value, whereas an Observable is a stream of values (from 0 to multiple values),
	you can apply RxJS operators to an Observable to get a new tailored stream.

# ES6
  Let/Const
  IIFE to block {}
  Fat Arrow
  Default Parameter/ Rest Parameter/ Rest Operator
  String Interpolation
  Mudule - export default/{Value}
  Class and Extends -->> Base class access -> super.toString()
  Static members and getter setter
  Promise
  

# Immutable
	1. Predictale
	2. Change tracking
	3. Easiness of implementing reactive interface
	4. Change history (Redo/Undo)
	5. having single source of truth
	6. structural sharing

# React JS
	Mount: constructor() -> static getDerivedStateFromProps(props, state) -> render() -> componentDidMount()
	Update: getDerivedStateFromProps(props, state) -> shouldComponentUpdate() -> render() -> 	getSnapshotBeforeUpdate(prevProps, prevState) -> componentDidUpdate(prevProps, prevState, snapshot)
			setState(), forceUpdate()
	Unmount: componentWillUnmount()
	ErrorHandling: static getDerivedStateFromError(err), componentDidCatch(err, errInfo)	
	


# TypeScript
	class Greeting { 
	   greet():void { 
		  console.log("Hello World!!!") 
	   } 
	} 
	var obj = new Greeting(); 
	obj.greet();
	TSC,
	//Generated by typescript 1.8.10
	var Greeting = (function () {
	   function Greeting() {
	   }
	   Greeting.prototype.greet = function () {
		  console.log("Hello World!!!");
	   };
		return Greeting;
	}());

	var obj = new Greeting();
	obj.greet()
	
	# Data Types
	1. Any - Supertype of all data type
	2. Built-in-types - number, string, boolean, void, null, undefined
	3. User-defined - Array, enum, class, interface
	
	#Interface
	interface IEmployee {
		empCode: number;
		empName: string;
		empDept?:string;
		readonly SSN: number;
		getSalary: (number) => number; // arrow function
		getManagerName(number): string; 
	}

# CSS
Specificity : Inline > ID > Class > Pseudo Elememt > Pseudo Class

# HTML5

WebWorkers - 
Executing eternal JS file without current window context (different thread). It does not affect the current webpage performance.

worker.postMessage(); - Sending MSG
onMessage(); - Receiving MSG


Server Sent Events
Getting response from server with an open channel.
onMessage();

# OPtimising WEB/JS Application
	1. Only sending the code a user needs - Code splitting and Lazy loading
	2. Minification - Minify and Uglify
	3. gzip - use gzip to compress text-based resources
	4. Removing unused code - Tree shaking
	5. Caching code to minimize network trips
	6. Break Out of Loops As Early As Possible
	7. Order Code to Minimise the Number of Operations
	8. Use Asynchronous Code to Prevent Thread Blocking
	9. Put static content to CDN
	10. gzip webfont


# ANGULAR

{
  path: 'post/:id',
  component: PostComponent,
  resolve: { hnData: HnResolver }
}

# Passing Data (RESOLVE)
this.router.navigateByUrl('/123', { state: { hello: 'world' } })
<a routerLink="/details" [state]="{ hello: 'world' }">Go</a>
<a [routerLink]="['/details/tt0257106']">Scary Movie 2</a>


import { Resolve, ActivatedRouteSnapshot } from "@angular/router";
import { CanActivate, ActivatedRouteSnapshot } from "@angular/router";
@Injectable()
export class HnResolver implements Resolve<any> {
  constructor(private hnService: HnService) {}

  resolve(route: ActivatedRouteSnapshot) {
    return this.hnService.getPost(route.paramMap.get('id'));
  }
  
  canActivate(route: ActivatedRouteSnapshot): Observable<boolean> {
    console.log("guard!");
    let imbdid = route.paramMap.get('imbdid');
    return this.httpClient.get('http://www.omdbapi.com/?i=' + imbdid + '&apikey=' + APIKEY).pipe(
      map(res => {
        if (res['Error']) {
          alert("Movie not found at guard!");
          return false;
        } else {
          return true;
        }
      }),
      catchError((err) => {
        return of(false);
      })
    );

}



# Transform(Pipe)
import { Pipe, PipeTransform } from '@angular/core';
@Pipe({name: 'uselessPipe'})
export class uselessPipe implements PipeTransform {
  transform(value: string, before: string, after: string): string {
    let newStr = `${before} ${value} ${after}`;
    return newStr;
  }
}
{{ user.name | uselessPipe:"Mr.":"the great" }}


# Viewencaptutation
import { Component, ViewEncapsulation } from '@angular/core';
@Component({
    selector: 'app-root',
    templateUrl: './app.component.html',
    styleUrls: ['./app.component.css'],
    encapsulation: ViewEncapsulation.None/ViewEncapsulation.Native[Shadow Dom #shadow-root]/Emulated[Default _ngcontent-c0]
})


# Reactive form
import { ReactiveFormsModule } from '@angular/forms'; //ngModule
import { FormBuilder, Validators } from "@angular/forms"; //component

export class AppComponent {
   City: any = ['Florida', 'South Dakota', 'Tennessee', 'Michigan']
  constructor(public fb: FormBuilder) { }

  /*########### Form ###########*/
  

  registrationForm = this.fb.group({
    cityName: ['']
  })
	
  changeCity(e) {
    this.cityName.setValue(e.target.value, {
      onlySelf: true
    })
  }
  onSubmit() {
    alert(JSON.stringify(this.registrationForm.value))
  }

}

<!-- Form starts -->
<form [formGroup]="registrationForm" (ngSubmit)="onSubmit()">

   <select class="custom-select">
      <option value="" disabled>Choose your city</option>
      <option>New York</option>
   </select>
   
   <select class="custom-select" (change)="changeCity($event)" formControlName="cityName">
	   <option value="" disabled>Choose your city</option>
	   <option *ngFor="let city of City" [ngValue]="city">{{city}}</option>
	</select>

   <button type="submit">Submit</button>
</form><!-- Form ends -->

################################
<form [formGroup]="myForm" (ngSubmit)="onSubmit(myForm)">
  <input formControlName="name" placeholder="Your name">
  <input formControlName="email" placeholder="Your email">
  <input formControlName="message" placeholder="Your message">
  <button type="submit">Send</button>
</form>
export class AppComponent implements OnInit {
  myForm: FormGroup;

  constructor(private fb: FormBuilder) {}
  ngOnInit() {
    this.myForm = new FormGroup({
      name: new FormControl('Benedict'),
      email: new FormControl(''),
      message: new FormControl('')
    });
  }
  OR,
  ngOnInit() {
  this.myForm = this.fb.group({
    name: ['Benedict', Validators.required],
    email: ['', [Validators.required, Validators.pattern('[a-z0-9.@]*')]],
    message: ['', [Validators.required, Validators.minLength(15)]]
  });
  }
}


# <ng-template> *ngIf
  <ng-container> *ngFor
  <ng-content> -> <project-content>

<ng-template #myTemplateRef>  
  This is a partial template  
</ng-template>

<div *ngTemplateOutlet="myTemplateRef">  </div>
***********************
<ng-template let-message="myMessage" #myTemplateRef>  </ng-template>
***********************
<div *ngTemplateOutlet="myTemplateRef; context:{message: 'This is a partial template'}"></div>

######################  SHOWING LOADER ##########################
<div class="lessons-list" *ngIf="lessons else loading">
  ... 
</div>
<ng-template [ngIf]="lessons" [ngIfElse]="loading">
   <div class="lessons-list">
     ... 
   </div>
</ng-template>
**********************************
<ng-template #loading>
    <div>Loading...</div>
</ng-template>





# Change Detection

String and boolian - Immutable
OnPush - Compare the references of the object
ChangeDetectorRef - this.cd.markForCheck(); //Checks mutatable object from parent thru @input
					this.cd.detached(); // Never look for changes
					this.cd.detectChanges(); //
					this.cd.reattached();

@Component({
  selector: 'tooltip',
  template: `
    <h1>{{config.position}}</h1>
    {{runChangeDetection}}
  `,
  changeDetection: ChangeDetectionStrategy.OnPush
})

detectChanges() //Child
ApplicationRef.tick() //application
markForCheck() //either as part of the current or next change detection cycle.

# RxJS

	const mySubject = new Rx.Subject(); //subscriptions that arrive late are missing always gives latest data
	mySub2 = mySubject.subscribe(x => console.log(x.toUpperCase()));

	# AS observable
	const mySubject = new Rx.Subject();
	const myObs = mySubject.asObservable(); // convert subject to observable
	
	# Repply subject
	const mySubject = new Rx.ReplaySubject(2); // holds the buffer
	
	# Behaviour subject
	Behavior subjects are similar to replay subjects, but will re-emit only the last emitted value, or a default value if no value has been previously emitted:
	const mySubject = new Rx.BehaviorSubject('Hey now!');

	mySubject.subscribe(x => {
	  console.log('From 1st sub:', x);
	});

throttling-and-debouncing-in-javascript


